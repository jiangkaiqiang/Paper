\section{Background}
\label{sec:fmi}
In this section, we present the syntax and semantics of FMU and timed automata separately. In order to verify the co-simulation of FMUs, we propose to encode FMUs by timed automata in subsection \ref{sec:encoding}. 

\subsection{FMU}
FMU is the model component which implements the methods defined in the FMI API \cite{Tripakis15}. Here, we present the syntax and semantics of FMU. The aim is to encode FMU into timed automata based on their semantics.
\begin{definition}
\textbf{FMU syntax}
We recall the definition of FMU. An FMU is a tuple $F=(S,U,Y,D,s_{0},set,get,doStep)$, where:
\end{definition}
\begin{itemize}
\item
$S$ denotes the set of states of $F$. 
\item
$U$ denotes the set of input port variables of $F$. Note that an element $u \in U$ is a variable, not a value, which ranges over a set of values $\mathbb{V}$. 
\item
$Y$ denotes the set of output port variables of $F$. Each $y \in Y$ ranges over the same set of values $\mathbb{V}$.
\item
$D \subseteq U \times Y$ denotes a set of input-output dependencies. $(u,y) \in D $ means that the output y is directly dependent on the value of u. The $I/O$ dependency information is used to ensure that a network of FMUs does not contain cyclic dependencies, and also to identify the order in which all variables are computed during a step.
\item
$s_{0} \in S$ denotes the initial state of $F$.
\item
$set : S \times U \times \mathbb{V} \rightarrow S$ denotes the function that sets the value of an input variable. Given current state $s \in S$, input variable $u \in U$, and value $v \in \mathbb{V}$, it returns the new state obtained by setting $u$ to $v$.
\item
$get : S \times Y \rightarrow \mathbb{V}$ denotes the function that returns the value of an output variable. Given state $s \in S$ and output variable $y \in Y$, $get(s,y)$ returns the value of $y$ in $s$.
\item
$doStep : S \times \mathbb{R}_{\geqslant{0}} \rightarrow S \times \mathbb{R}_{\geqslant{0}}$ denotes the function that implements one simulation step. Given current state $s$, and a non-negative real value $h \in \mathbb{R}_{\geqslant{0}}$, $doStep(s,h)$ returns a pair $(s^{\prime},h^{\prime})$ such that:
\\
When $h^{\prime} = h$, it indicates that $F$ accepts the time step $h$ and reaches the new state $s^{\prime}$;
\\
When $0 \leqslant h^{\prime} < h$, this means that $F$ rejects the time step $h$, but making partial progress up to $h^{\prime}$, and reach the new location $s^{\prime}$.
\end{itemize}
\begin{definition}
\textbf{FMU semantics}
Given the FMU $F=(S,U,Y,D,s_{0},set,get,doStep)$,
\end{definition} 
The behavior of $F$ depends on the functions $doStep$, which is a function of a timed input sequence (TIS). A TIS is an infinite sequence 
$v_{0}h_{1}v_{1}h_{2}v_{2}h_{3}...$
of alternating input assignments $v_{i}$, and time delays $h_{i}$. An input assignment is the value of function $v : U \rightarrow \mathbb{V}$. That is, $v$ assigns a value to every input variable in $U$.
A TIS denotes a running of $FMU$, which is an infinite sequence of quadruples $(t,s,v,v^{\prime})$, where $t \in \mathbb{R}_{\geqslant{0}}$ is a time instant, $s \in S$ is a state of $F$, $v$ is an input assignment, and $v^{\prime} : Y \rightarrow \mathbb{V}$ is an output assignment
 
TIS := $(t_{0},s_{0},v_{0},v_{0}^{\prime}), (t_{1},s_{1},v_{1},v_{1}^{\prime}),(t_{2},s_{2},v_{2},v_{2}^{\prime}), ..., (t_{i},$
$s_{i},v_{i},v_{i}^{\prime}), (t_{i+1},s_{i+1},v_{i+1},v_{i+1}^{\prime}), ...$ is
defined as follows:
\begin{itemize}
\item
$t_{0} = 0$ and $s_{0}$ is the initial state of $F$.
\item
For each $i \geqslant 1$, $t_{i} = t_{0} + \sum_{k = 1}^i h_{k}$
\item
Given the current state $s_{i}$, the function $set$ is used to set all input variables to the values specified by $v$. Then $F$ reaches a new state $s_{i}^{\prime}$. The function $get$ is used to get the values of all output variables $v_{i}^{\prime}$.
\item 
We assume that $doStep(s_{i}, h_{i+1}) = (s_{i+1},h_{i+1})$ based on the assumption that every $h_{i}$ is accepted by $F$, $F$ will reach the next state $s_{i+1}$.
\end{itemize}

\subsection{Timed Automata}
Timed automata (TA) \cite{BehrmannDLHPYH06} is a theory to model the behavior of real-time systems. It provides a powerful way to annotate state-transition graphs with many real-valued clocks. In this section, we introduce the syntax and semantics of timed automata. 
\begin{definition}
\textbf{Timed automata syntax}
A timed automaton is a tuple $\textit{A}=(L,X,l_{0},E_{i},E_{o},I)$, where:
\end{definition}
\begin{itemize}
\item
L is a finite set of locations;
\item
X is a finite set of clocks;
\item
$l_{0} \in  L$ is the initial state;
\item
The set of guards $G(x)$ is defined by the grammar $g := x \bowtie c \mid g \land g$, where $x \in X$, $c \in \mathbb{N}$ and $\bowtie~\in \{<,\leqslant,\geqslant,>\}$. $E \subseteq L \times G(X) \times 2^X \times L$ is a set of edges labelled by guards and a set of clocks to be reset;
\item
$E_{i}$ is a set of input events.
\item
$E_{o}$ is a set of output events.
\item
$I : L \rightarrow G(X)$ assigns invariants to clocks.
\end{itemize}
A clock valuation is a function $v : X \rightarrow \mathbb{R}_{\geqslant{0}}$. If $\delta \in \mathbb{R}_{\geqslant{0}}$, then $v + \delta$ denotes the valuation such that for each clock $x \in X$, $(v + \delta)(x) = v(x) + \delta$. If $Y \subseteq X$, then $v[Y := 0]$ denotes the valuation such that for each clock $x \in X~Y$, $v[Y := 0](x) = v(x)$ and for each clock $x \in Y$, $v[Y := 0](x) = 0$. The satisfaction relation $v \models g$ for $g \in G(x)$ is defined in the natural way.
\begin{definition}
\textbf{Timed automata semantics} 
The semantics of a timed automaton $\textit{A} = (L,X,l_{0},E,E_{i},E_{o},I)$ is defined by a transition system $L_{\textit{A}} = (L,l_{0},\rightarrow)$, 
\end{definition}
where $L = L \times \mathbb{R}_{\geqslant{0}}^X$ is the set of locations, $l_{0} = (l_{0},v_{0})$ is the initial location, $v_{0}(x) = 0$ for all $x \in X$, and $\rightarrow \subseteq L \times L$ is the set of transitions defined by :
\begin{itemize}
\item
$(l,v) \xrightarrow{\in(\delta)} (l,v+\delta)$ if $\forall0 \leqslant \delta^{\prime} \leqslant \delta : (v + \delta^{\prime}) \models I(s)$;
\item
$(l,v) \rightarrow (l^{\prime},v[Y := 0])$ if there exists $(l,g,Y,l^{\prime}) \in E$ such that $v \models g$ and $v[Y := 0] \models I(l^{\prime})$.
\end{itemize}
The reachability problem for an automaton $A$ and a location $l$ is to decide whether there is a state $(l,v)$ reachable from $(l_{0},v_{0})$ in the transition system $L_{A}$. As usual, for verification purposes, we define a symbolic semantics for timed automata. For universality, the definition uses arbitrary sets of clock valuations.

Consider a location $l$ such that for any $t \in X$, for fixed constant $x \in X$, clock valuation $x + t \in X$. A possible execution fragment starting from this location is

$(l,t) \xrightarrow{x_{1}} (l,t+x_{1}) \xrightarrow{x_{2}} (l,t+x_{1}+x_{2}) \xrightarrow{x_{3}} (l,t+x_{1}+x_{2}+x_{3}) \xrightarrow{x_{4}}...$

where $x_{i} > 0$ and the infinite sequence $x_{1} + x_{2} + . . .$ converges toward $x$. 





