
\section{Background}
\label{sec:fmi}
We give some background on three main ingredients of our work: FMI 2.0, FMU and timed automata. Then, we propose to encode FMUs by timed automata.
\subsection{FMI 2.0}
FMI \cite{BromanBGLMTW13} defines an standard applied to composing model components which are designed with different modeling tools. The FMI standard was first developed in the MODELISAR project started in 2008 and supported by a large number of software companies and research centers. FMI offers the means for model based development of systems and is particularly appropriate way to develop complex CPSs. The FMI standard supports both co-simulation and  model exchange. However, in this paper, we focus on the co-simulation in FMI 2.0.
Compared with the FMI 1.0, there are two important additions: $fmiGetFMUstate$ and $fmiSetFMUstate$, which allow the master to copy and later restore the complete state of an FMU slave. The two functions provide an ordinary mechanism for rollback, however, they are not practical for the reason that it's infeasible to restore so many states for a huge system. The function $fmiDoStep$ is to control the computation of time steps, called by the MA to orchestrate the exchange of data among the FMUs during the entire co-simulation. 
\\
\\
$fmiStatus~fmiDoStep(
\\
~~~~fmiComponent~c,
\\
~~~~fmiReal~currentCommunicationPoint,
\\
~~~~fmiReal~communicationStepSize,
\\
~~~~fmiBoolean~noSetFMUStatePriorToCurrentPoint)$;
\\
\\
The $currentCommunicationPoint$ argument is the current communication time of the master. The $communicationStepSize$ is the time step that the master proposes to the slave. Given a time step, the slave may accept or reject the step. For example, it may reject it because the step size is so large that causes a discrete event within the step. If the argument $noSetFMUStatePriorToCurrentPoint$ is true, the master will no longer call $fmiSetFMUstate$ for time instants prior to $currentCommunic \\ tionPoint$ in this simulation run. 
\subsection{FMU}
FMU is the model component which implements the methods defined in the FMI API \cite{Tripakis15}.
\begin{definition}
\textbf{FMU syntax}
We can look back on the definition of FMU. An FMU is a tuple $F=(S,U,Y,D,s_{0},set,get,doStep)$, where:
\end{definition}
\begin{itemize}
\item
$S$ denotes the set of state valuations of $F$. 
\item
$U$ denotes the set of input port variables of $F$. Note that an element $u \in U$ is a variable, not a value, which ranges over a set of values $\mathbb{V}$. 
\item
$Y$ denotes the set of output port variables of $F$. Each $y \in Y$ ranges over the same set of values $\mathbb{V}$.
\item
$D \subseteq U \times Y$ denotes a set of input-output dependencies. $(u,y) \in D $ means that the output y is directly dependent on the value of u. The $I/O$ dependency information is used to ensure that a network of FMUs does not contain cyclic dependencies, and also to identify the order in which all variables are computed during a step.
\item
$s_{0} \in S$ denotes the initial state of $F$.
\item
$set : S \times U \times \mathbb{V} \rightarrow S$ denotes the function that sets the value of an input variable. Given current state $s \in S$, input variable $u \in U$, and value $v \in \mathbb{V}$, it returns the new state obtained by setting $u$ to $v$.
\item
$get : S \times Y \rightarrow \mathbb{V}$ denotes the function that returns the value of an output variable. Given state $s \in S$ and output variable $y \in Y$, $get(s,y)$ returns the value of $y$ in $s$.
\item
$doStep : S \times \mathbb{R}_{\geqslant{0}} \rightarrow S \times \mathbb{R}_{\geqslant{0}}$ denotes the function that implements one simulation step. Given current state $s$,~and a non-negative real value $h \in \mathbb{R}_{\geqslant{0}}$,~    $doStep(s,h)$ returns a pair $(s^{\prime},h^{\prime})$ such that:
\\
When $h^{\prime} = h$, it indicates that $F$ accepts the time step $h$ and reaches the new state $s^{\prime}$;
\\
When $0 \leqslant h^{\prime} < h$, this means that $F$ rejects the time step $h$, but making partial progress up to $h^{\prime}$, and reach the new state $s^{\prime}$.
\end{itemize}
\begin{definition}
\textbf{FMU semantics}
Consider an FMU $F=(S,U,Y,D,s_{0},set,get,doStep)$.
\end{definition} 
The behavior of $F$ depends on functions such as $doStep$. So the behavior of $F$ is a function of a timed input sequence (TIS). A TIS is an infinite sequence 
$v_{0}h_{1}v_{1}h_{2}v_{2}h_{3}...$
of alternating input assignments $v_{i}$, and time delays $h_{i}$. An input assignment is a function $v : U \rightarrow \mathbb{V}$. That is, $v$ assigns a value to every input variable in $U$.
A TIS like the above defines a run of $F$, which is an infinite sequence of quadruples $(t,s,v,v^{\prime})$, where $t \in \mathbb{R}_{\geqslant{0}}$ is a time instant, $s \in S$ is a state of $F$, $v$ is an input assignment, and $v^{\prime} : Y \rightarrow \mathbb{V}$ is an output assignment :
$(t_{0},s_{0},v_{0},v_{0}^{\prime})(t_{1},s_{1},v_{1},v_{1}^{\prime})(t_{2},s_{2},v_{2},v_{2}^{\prime})...$
defined as follows:
\begin{itemize}
\item
$t_{0} = 0$ and $s_{0}$ is the initial state of $F$.
\item
For each $i \geqslant 1$, $t_{i} = t_{0} + \sum_{k = 1}^i h_{k}$
\item
Given the current state $s_{i}$, the function $set$ is used to set all input variables to the values specified by $v$. Then $F$ reaches a new state $s_{i}^{\prime}$. Next, the function $get$ is used to get the values of all output variables $v_{i}^{\prime}$.
\item 
We assume that $doStep(s_{i}^{\prime}, h_{i+1}) = (s_{i+1},h_{i+1})$ based on the assumption that every $h_{i}$ is accepted by $F$, and results in the next state $s_{i+1}$.
\end{itemize}
\subsection{Timed Automata}
Timed automata \cite{BehrmannDLHPYH06} is a theory to model the behavior of real-time systems. Its definition provides a powerful way to annotate state-transition graphs with many real-valued clocks. In this section, we introduce the syntax and semantics of timed automata.
\begin{definition}
\textbf{Timed automata syntax}
A timed automaton is a tuple $\textit{A}=(L,X,l_{0},E,E_{O},E_{I},I)$, where:
\end{definition}
\begin{itemize}
\item
L is a finite set of locations;
\item
X is a finite set of clocks;
\item
$l_{0}\in  L$ is an initial location;
\item
The set of guards $G(x)$ is defined by the grammar $g := x \bowtie c \mid g \land g$, where $x \in X$, $c \in \mathbb{N}$ and $\bowtie~\in \{<,\leqslant,\geqslant,>\}$. $E\subseteq L \times G(X) \times 2^X \times L$ is a set of edges labelled by guards and a set of clocks to be reset;
\item
$E_{O}$ is a set of input events.
\item
$E_{I}$ is a set of output events.
\item
$I : L \rightarrow G(X)$ assigns invariants to clocks.
\end{itemize}
A clock valuation is a function $v : X \rightarrow \mathbb{R}_{\geqslant{0}}$. If $\delta \in \mathbb{R}_{\geqslant{0}}$, then $v + \delta$ denotes the valuation such that for each clock $x \in X$, $(v + \delta)(x) = v(x) + \delta$. If $Y \subseteq X$, then $v[Y := 0]$ denotes the valuation such that for each clock $x \in X~Y$, $v[Y := 0 ](x) = v(x)$ and for each clock $x \in Y$, $v[Y := 0](x) = 0$. The satisfaction relation $v \models g$ for $g \in G(x)$ is defined in the natural way.
\begin{definition}
\textbf{Timed automata semantics} 
The semantics of a timed automaton $\textit{A} = (L,X,l_{0},E, \\E_{O},E_{I},I)$ is defined by a transition system $S_{\textit{A}} = (S,s_{0},\rightarrow)$, \end{definition}
where $S = L \times \mathbb{R}_{\geqslant{0}}^X$ is the set of states, $s_{0} = (l_{0},v_{0})$ is the initial state, $v_{0}(x) = 0$ for all $x \in X$, and $\rightarrow \subseteq S \times S$ is the set of transitions defined by :
\begin{itemize}
\item
$(l,v) \xrightarrow{\in(\delta)} (l,v+\delta)$ if $\forall0 \leqslant \delta^{\prime} \leqslant \delta : (v + \delta^{\prime}) \models I(l)$;
\item
$(l,v) \rightarrow(l^{\prime},v[Y := 0])$ if there exists $(l,g,Y,l^{\prime}) \in E$ such that $v \models g$ and $v[Y := 0 ] \models I(l^{\prime})$.
\end{itemize}
The reachability problem for an automaton $A$ and a location $l$ is to decide whether there is a state $(l,v)$ reachable from $(l_{0},v_{0})$ in the transition system $S_{A}$. As usual, for verification purposes, we define a symbolic semantics for timed automata. For universality, the definition uses arbitrary sets of clock valuations.
\subsection{Encoding FMUs by timed automata}
Given an FMU $F=(S,U,Y,D,s_{0},set,get,doStep)$, we model this FMU by a timed automaton $A = (L,X,l_{0},E,E_{O},E_{I},I)$, where:
\begin{itemize}
\item
$L$ is a set of finite locations. Note that a location of TA has the same form as a state of the $F$.
\item
The initial location $l_{0}$ is such that $s$ is set to $s_{0}$. 
\item
Each input variable $u \in U$ ranges over $E_{I} \cup \{absent\}$.
\item
Each output variable $y \in Y$ ranges over $E_{O} \cup \{absent\}$.
\item
An input event in $e \in E_{O}$ is such that the function $set$ of $F$ sets the input variable $u$ to a given value. 
\item
An output event in $e \in E_{I}$ indicates that the function $get$ of $F$ gets the output variable $y$. The set of values in the $E_{I}$ is the $Y$.  
\item
The communication with input and output events in TA is the same as the I/O dependencies information in FMU. $(u,y) \in D$ denotes that output y depend on input u. The output events also depend on the input events.
\item
For any $e \in E$ of A, there is a transition $l \xrightarrow{e} l^{\prime}$, which may be found after the function $doStep$ is executing. For instance, if there is a transition $l \xrightarrow{e} l^{\prime}$, at the same time $doStep(s,h)$ may be called which indicates that $F$ accepts the time step $h$ and reaches the new state $s^{\prime}$. However, $F$ maybe rejects the time step for the reason which we have discussed above and this process can also be described in the TA. If there is a rollback behavior happens after the $F$ rejects the time step $h$, the transition in TA could be a edge $l \xrightarrow{e} l$, which denotes that a location travels to itself.
\end{itemize}
Although there are semantic gaps between FMUs and timed automata, we provide a  appropriate transformation above to solve the problem. So, we believe that it's feasible to encode the FMUs by timed automata. In the following sections, we will model the FMUs with the timed automata in UPPAAL.


