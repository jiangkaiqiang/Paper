\section{Background}
\label{sec:fmi}
In this section, we brifely recall the syntax and semantics of FMU and TA. The semantic gap is the main problem when we apply TA-based model checking technology to verify coordination between FMUs. To bridge the semantic gap between FMU and TA, we propose encoding rules to specify FMU with TA. The detailed encoding process will be discuss in Section \ref{sec:encoding}. 

\subsection{FMU}
An FMU is a component which implements the methods defined in the FMI API \cite{Tripakis15}. We present the syntax and semantics of FMU. The aim is to encode FMU as TA based on their semantics.
\begin{definition}
\textbf{FMU syntax}

An FMU is a tuple $F=(S,U,Y,D,s_{0},set,get,doStep)$, where:
\end{definition}
\begin{itemize}
\item
$S$ denotes the set of states of $F$. 
\item
$U$ denotes the set of input variables of $F$. Note that an element $u \in U$ is a variable which ranges over a set of values $\mathbb{V}$. 
\item
$Y$ denotes the set of output variables of $F$. Each $y \in Y$ ranges over the set of values $\mathbb{V}$.
\item
$D \subseteq U \times Y$ denotes a set of input-output dependencies. $(u,y) \in D $ means that the output $y$ is directly dependent on the value of $u$. 
%The $I/O$ dependency information is used to ensure that a network of FMUs does not contain cyclic dependencies, and also to identify the order in which all variables are computed during a simulation step.
\item
$s_{0} \in S$ denotes the initial state of $F$.
\item
$set : S \times U \times \mathbb{V} \rightarrow S$ denotes that the function sets the value of an input variable. Given current state $s \in S$, input variable $u \in U$, and value $v \in \mathbb{V}$, it returns a new state obtained by setting $u$ to $v$.
\item
$get : S \times Y \rightarrow \mathbb{V}$ denotes that the  function returns the value of an output variable. Given state $s \in S$ and output variable $y \in Y$, $get(s,y)$ returns the value of $y$ in $s$.
\item
$doStep : S \times \mathbb{R}_{\geqslant{0}} \rightarrow S \times \mathbb{R}_{\geqslant{0}}$ denotes that the function implements one simulation step. Given current state $s$, and a non-negative real $h \in \mathbb{R}_{\geqslant{0}}$, $doStep(s,h)$ returns a pair $(s^{\prime},h^{\prime})$ such that:
\\
    When $h^{\prime} = h$, it indicates that $F$ accepts the time step $h$ and reaches the new state $s^{\prime}$;
\\
    When $0 \leqslant h^{\prime} < h$, it means that $F$ rejects the time step $h$, but makes partial progress up to $h^{\prime}$, and reaches the new state $s^{\prime}$.
\end{itemize}
\begin{definition}
\textbf{FMU semantics}
\end{definition} 
Given the FMU $F=(S,U,Y,D,s_{0},set,get,doStep)$, The behavior of $F$ depends on the function $doStep$, which is a function of a Timed Input Sequence (TIS).
%A TIS is an infinite sequence $v_{0}h_{1}v_{1}h_{2}v_{2}h_{3}...$ of alternating input assignments $v_{i}$, and time delays $h_{i}$. An input assignment is the value of function $v : U \rightarrow \mathbb{V}$. That is, $v$ assigns a value to every input variable in $U$.
A TIS denotes a running of $FMU$, which is an infinite sequence of quadruples $(t,s,v,v^{\prime})$, where $t \in \mathbb{R}_{\geqslant{0}}$ is a time instant, $s \in S$ is a state of $F$, $v$ is an input assignment, and $v^{\prime} : Y \rightarrow \mathbb{V}$ is an output assignment.
 
TIS = $(t_{0},s_{0},v_{0},v_{0}^{\prime}), (t_{1},s_{1},v_{1},v_{1}^{\prime}),(t_{2},s_{2},v_{2},v_{2}^{\prime}), ..., (t_{i},$
$s_{i},v_{i},v_{i}^{\prime}), (t_{i+1},s_{i+1},v_{i+1},v_{i+1}^{\prime}), ...$ is
defined as follows:
\begin{itemize}
\item
$t_{0} = 0$ and $s_{0}$ is the initial state of $F$.
\item
For each $i \geqslant 1$, $t_{i} = t_{0} + \sum_{k = 1}^i h_{k}$
\item
Given the current state $s_{i}$, the function $set$ is used to set all input variables to the values specified by $v$. Then $F$ reaches a new state $s_{i}^{\prime}$. The function $get$ is used to get the values of all output variables $v_{i}^{\prime}$.
\item 
We assume that $doStep(s_{i}, h_{i+1}) = (s_{i+1},h_{i+1})$ based on the assumption that every $h_{i}$ is accepted by $F$. $F$ will reach the next state $s_{i+1}$.
\end{itemize}
Therefore, the semantics of an FMU can be defined by a labelled transition system.
\subsection{Timed Automaton}
TA \cite{BehrmannDLHPYH06} is a classic theory to model the behavior of real-time system. It provides a powerful way to annotate state-transition graphs with many real-valued clocks. In this subsection, we recall the syntax and semantics of TA. 
\begin{definition}
\textbf{TA syntax}

A TA over a finite set of clocks $X$ and a finite set of actions $Act$ is a quadruple $\textit{A}=(L,l_{0},E,I)$, where:
\end{definition}
\begin{itemize}
\item
L is a finite set of locations which ranges over by $l$;
\item
$l_{0} \in  L$ is the initial location;
\item
The set of guards $G(x)$ is defined by the grammar $g = x \bowtie c \mid g \land g$, where $x \in X$, $c \in \mathbb{N}$ and $\bowtie~\in \{<,\leqslant,\geqslant,>,=\}$. 
\item
$E \subseteq L \times G(X) \times Act \times 2^X \times L$ is a set of edges labelled by guards and a set of clocks, where $Act = Act_{i} \cup Act_{o}$. $Act_{i}$ is a set of input actions and $Act_{o}$ is a set of output actions.
\item
$I : L \rightarrow G(X)$ assigns invariants to locations.
\end{itemize}
A clock valuation is a function $v : X \rightarrow \mathbb{R}_{\geqslant{0}}$. If $\delta \in \mathbb{R}_{\geqslant{0}}$, then $v + \delta$ denotes the valuation such that for each clock $x \in X$, $(v + \delta)(x) = v(x) + \delta$. If $Y \subseteq X$, then $v[Y = 0]$ denotes the valuation such that for each clock $x \in X, Y$, $v[Y = 0](x) = v(x)$ and for each clock $x \in Y$, $v[Y = 0](x) = 0$.
\begin{definition}
\textbf{TA semantics} 

The semantics of a TA $\textit{A}=(L,l_{0},E,I)$ is defined by a labelled transition system $L_{\textit{A}} = (Proc,Lab,\lbrace {{\xrightarrow{\alpha}}} \mid \alpha \in Lab \rbrace)$, where:
\end{definition}
\begin{itemize}
\item 
$Proc = \lbrace(l,v) \mid (l,v) \in L \times (X \rightarrow \mathbb{R}_{\geqslant{0}})$ and $v \models I(l) \rbrace$, i.e., states are of the form $(l,v)$, where $l$ is the location of the TA and $v$ is a valuation that satisfies the invariant of $I(l)$;
\item
$Lab = Act \cup \mathbb{R}_{\geqslant{0}}$ is the set of labels; and 
\item
the transition relation is defined by 

$(l,v) \xrightarrow{\alpha} (l^{\prime},v^{\prime})$ if there is an edge $(l \xrightarrow{g,\alpha,r} l^{\prime}) \in E$, such that $v \models g$, $v^{\prime} = v[r]$ and $v^{\prime} \models I(l^{\prime})$

$(l,v) \xrightarrow{d} (l,v+d)$ for all $d \in  \mathbb{R}_{\geqslant{0}}$, such that $v \models I(l)$ and $v + d \models I(l)$
\end{itemize}
The reachability problem for an automaton $A$ and a location $l$ is to decide whether there is a state $(l,v)$ reachable from $(l_{0},v_{0})$ in the transition system $L_{A}$. As usual, for verification purposes, we define a symbolic semantics for TA. For universality, the definition uses arbitrary sets of clock valuations.

Consider a location $l$ such that for any $x \in X$, for fixed constant $t \in X$, clock valuation $t + x \in X$. A possible execution fragment starting from this location is

$(l,t) \xrightarrow{x_{1}} (l,t+x_{1}) \xrightarrow{x_{2}} (l,t+x_{1}+x_{2}) \xrightarrow{x_{3}} (l,t+x_{1}+x_{2}+x_{3}) \xrightarrow{x_{4}}...\xrightarrow{x_{i}}(l,t+x_{1}+x_{2}+x_{3}+...+x_{i}) \xrightarrow{x_{i+1}}...$

where $x_{i} > 0$ and the infinite sequence $x_{1} + x_{2} + . . .$ converges toward $x$. 





