\section{Introduction}

\textit{Cyber-physical systems} (CPS) are integration of computation with physical processes whose behavior is defined by both computational and physical parts of the system \cite{Zanero17}. Embedded computers and networks monitor and control the physical processes, usually with feedback loops where physical processes affect computations and vice versa. The heterogeneity is one of the main characteristics of CPS. The components of CPS are of various types, requiring interfacing and interoperability across multiple platforms and different models of computation. Verifying heterogeneous CPS is a challenge problem. The simulation-based verification is a promising approach, which is based on the emerging industry standard Functional Mock-up Interface (FMI) \cite{Blochwitz2011The}\cite{BromanBGLMTW13}. It is a standard to support simulation of complex systems composed of heterogeneous components, by coupling the different models with their own solver in a co-simulation environment.

The FMI standard was first developed in the MODELISAR project started in 2008 and supported by a large number of software companies and research centers \cite{ClauMODELISAR}. FMI offers the means for model based development of systems and is particularly appropriate way to develop complex CPS. The FMI standard supports both co-simulation and  model exchange. In this paper, we focus on verifying the coordination of CPS with FMI 2.0 based co-simulation.
%Compared with the FMI 1.0, there are two important new functions: \emph{fmiGetFMUstate} and \emph{fmiSetFMUstate}, which allow the master to copy and restore all states of an FMU slave. These two functions provide a basic mechanism for rollback. 
The soul of FMI-based co-simulation is Master Algorithm (MA) \cite{AckerDVM15} and connector configuration between Functional Mock-up Units (FMU) \cite{Tripakis15}, which specifies the orchestration and the exchange of data among FMUs during the whole coordination process. By this way, the coordination of CPS is implemented by FMI-based co-simulation. To ensure the correctness of coordination, we need verify MA and connector configuration with model checking. However, the MA is not a part of the FMI standard. This implies that the user or tool vendor needs to develop a sophisticated orchestration algorithm for the problem at hand. 
%Is the MA deadlock free?
%Dose the MA satisfy the reachability? To solve these problem, we can verify the MAs with model checking technology.
There are three versions of MA \cite{BromanBGLMTW13}: fixed step algorithm, rollback algorithm and predictable step size algorithm. Rollback and predictable step size algorithms are based on the extension of FMI 2.0, which supports the rollback and a predict function. P.G Larsen et al. \cite{Larsen2016Integrated} formally analysed the fixed step and rollback algorithms with the FDR3 refinement checker. However, there still lack effective method to verify the whole FMI-based coordination process. Based on our previous work, we found that the simulation process of coordination is time-intensive. Timed Automaton (TA) \cite{BehrmannDLHPYH06} is a finite automaton extended with a finite set of real-valued clocks, which is a classic formalism to specify time-related system. In this paper, we attempt to model the MA with TA and verify the correctness of MA. Furthermore, we also attempt to encode the component of CPS with TA and verify the architecture of whole system with model checker UPPAAL \cite{BehrmannDLHPYH06}. To achieve our goal, we propose a novel approach to model check the coordination of CPS with TA.

\textbf{Our main contributions are as follows}:
\begin{itemize}
\item
we propose a novel approach to verify the coordination for CPS with model checking. To bridge the gap between FMU and the model checker, we propose some encoding rules to encode FMU as TA.
\item
We model and verify three various MA to ensure the correctness of the coordination. With the help of UPPAAL, we analyse the reachability, livelock and deadlock of three MA.
%\item
%We present a novel approach to model check several properties of the co-simulation based on timed automata. With the help of model checker, the property such as livelock, deadlock and reachability of the co-simulation are verified. 
\item
The prototype for model checking coordination of CPS is developing, which is integrated in our Modana platform \cite{Cheng2015Modana}(https://github.com/ECNU-MODANA/AL-Modana.git). We have implemented the \textit{SysML modeling environment} and the \textit{co-simulator} to simulate CPS \cite{Fritzson1998Modelica}.
\end{itemize}
The main novelty of our work, compared to the previous work, is that we propose to verify coordination of CPS with TA-based model checking. As far as we know, there is few existing approaches support TA-based model checking for the coordination of CPS.

The remainder of this paper is organized as follows. In Section~\ref{sec:fmi}, we briefly review the technical background including FMI, FMU and TA. Then, we present the technical road map of our approach and discuss how to encode FMU by TA with the help of their semantic mapping rules in Section~\ref{sec:encoding}. In Section~\ref{sec:ma}, we model three versions of MA with TA and verify their properties such as the livelock and deadlock. Section~\ref{sec:sysml} presents a case study to demonstrate the feasibility of our approach. We model the architecture of the water tank system with SysML Block Definition Diagrams (BDD) \cite{SemerathBHSV17}, and then obtains the FMU component of each block and the connection between FMUs. We encode the FMU of water tank with TA and verify the correctness of the coordination between components of the water tank system with UPPAAL. Finally, we position our work with respect to related work before concluding and discussing possible future extensions.




















%The syntax of TA is as follows:
%\par
%\textbf{Timed Automata}
%A timed automata over a finite set of clocks $C$ and a finite set of actions $Sigma$ is a quintuple $\textit{H}=(L,l_{0},\Sigma,E,I)$, where
%\begin{itemize}
%\item
%$L$ is a finite set of locations,
%\item
%$l_{0}\in L$ is the initial location,
%\item
%$\Sigma$ is a finite set of actions, and $\Sigma=\Sigma_{i}+\Sigma_{o}$, where $\Sigma_{i}$ is the set of input actions, $\Sigma_{o}$ is the set of output actions,
%\item
%$E$ is a finite set of transactions, where $E\subseteq L \times \mathcal{B(C)}\times \Sigma \times 2^C\times L$
%\item
%$I:L\rightarrow \mathcal{B(C)})$ assigns invariants to locations.
%\end{itemize}